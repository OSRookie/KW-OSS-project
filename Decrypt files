/// <summary>
/// 파일 해독
/// </summary>
/// <param name="inFile">해독 할 파일</param>
/// <param name="outFile">복호화 후 출력 파일</param>
/// <param name="password">암호 해독</param>
public static void DecryptFile(string inFile, string outFile, string password)
{
    // 열린 파일 스트림 만들기
    using (FileStream fin = File.OpenRead(inFile),
        fout = File.OpenWrite(outFile))
    {
        int size = (int)fin.Length;
        byte[] bytes = new byte[BUFFER_SIZE];
        int read = -1;
        int value = 0;
        int outValue = 0;

        byte[] IV = new byte[16];
        fin.Read(IV, 0, 16);
        byte[] salt = new byte[16];
        fin.Read(salt, 0, 16);

        SymmetricAlgorithm sma = DESFileClass.CreateRijndael(password, salt);
        sma.IV = IV;

        value = 32;
        long lSize = -1;

        // 해시 개체 생성, 파일 확인
        HashAlgorithm hasher = SHA256.Create();

        using (CryptoStream cin = new CryptoStream(fin, sma.CreateDecryptor(), CryptoStreamMode.Read),
            chash = new CryptoStream(Stream.Null, hasher, CryptoStreamMode.Write))
        {
            // 파일 길이 읽기
            BinaryReader br = new BinaryReader(cin);
            lSize = br.ReadInt64();
            ulong tag = br.ReadUInt64();

            if (FC_TAG != tag)
                throw new CryptoHelpException("파일이 손상되었습니다");

            long numReads = lSize / BUFFER_SIZE;

            long slack = (long)lSize % BUFFER_SIZE;

            for (int i = 0; i < numReads; ++i)
            {
                read = cin.Read(bytes, 0, bytes.Length);
                fout.Write(bytes, 0, read);
                chash.Write(bytes, 0, read);
                value += read;
                outValue += read;
            }

            if (slack > 0)
            {
                read = cin.Read(bytes, 0, (int)slack);
                fout.Write(bytes, 0, read);
                chash.Write(bytes, 0, read);
                value += read;
                outValue += read;
            }

            chash.Flush();
            chash.Close();

            fout.Flush();
            fout.Close();

            byte[] curHash = hasher.Hash;

            //비교 및 이전 해시 개체 가져 오기
            byte[] oldHash = new byte[hasher.HashSize / 8];
            read = cin.Read(oldHash, 0, oldHash.Length);
            if ((oldHash.Length != read) || (!CheckByteArrays(oldHash, curHash)))
                throw new CryptoHelpException("파일이 손상되었습니다");
        }

        if (outValue != lSize)
            throw new CryptoHelpException("파일 크기가 일치하지 않습니다");
    }
}
    }
}
